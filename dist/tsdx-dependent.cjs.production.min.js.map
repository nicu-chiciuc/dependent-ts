{"version":3,"file":"tsdx-dependent.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["// https://stackoverflow.com/a/50375286/2659549\nexport type UnionToIntersection<U> = (U extends any\n? (k: U) => void\n: never) extends (k: infer I) => void\n  ? I\n  : never;\n\nexport type UnpackPromise<T> = T extends Promise<infer U> ? U : T;\n\n/**\n * Use this instead of {}. It seems that {} causes problems especially when used in generics.\n */\nexport type EmptyObject = Record<string, unknown>;\n\nexport type Arguments<T extends (...args: unknown[]) => unknown> = T extends (\n  ...args: infer R\n) => unknown\n  ? R\n  : never;\nexport type FirstArgument<\n  T extends (arg: any, ...args: any[]) => any\n> = T extends (val: infer R, ...args: any[]) => any ? R : never;\nexport type SecondArgument<\n  T extends (first: any, second: any, ...args: any[]) => any\n> = T extends (first: any, second: infer R, ...args: any[]) => any ? R : never;\n\n/**\n * Given a function of type `(v: A) => Ap | (v: B) => Bp`\n * transform it's type into `(v: A | B) => Ap | Bp`\n */\nexport type UnionFuncFix<F extends (arg: any) => any> = (\n  value: FirstArgument<F>\n) => ReturnType<F>;\n\n// https://www.roryba.in/programming/2019/10/12/flattening-typescript-union-types.html\n// Flattens two union types into a single type with optional values\n// i.e. FlattenUnion<{ a: number, c: number } | { b: string, c: number }> = { a?: number, b?: string, c: number }\nexport type FlattenUnion<T> = {\n  [K in keyof UnionToIntersection<T>]: K extends keyof T\n    ? T[K] extends unknown[]\n      ? T[K] // eslint-disable-next-line @typescript-eslint/ban-types\n      : T[K] extends object\n      ? FlattenUnion<T[K]>\n      : T[K]\n    : UnionToIntersection<T>[K] | undefined;\n};\n\n/**\n * Different implementation of Array1/Array2/...\n *\n * Not sure if it provides any advantages\n */\nexport type ArrayN<N extends number, T> = N extends 1\n  ? [T, ...T[]]\n  : N extends 2\n  ? [T, T, ...T[]]\n  : N extends 3\n  ? [T, T, T, ...T[]]\n  : N extends 4\n  ? [T, T, T, T, ...T[]]\n  : N extends 5\n  ? [T, T, T, T, T, ...T[]]\n  : N extends 6\n  ? [T, T, T, T, T, T, ...T[]]\n  : N extends 7\n  ? [T, T, T, T, T, T, T, ...T[]]\n  : T[];\n\nexport type Array1<T> = [T, ...T[]];\nexport type Array2<T> = [T, T, ...T[]];\nexport type Array3<T> = [T, T, T, ...T[]];\nexport type Array4<T> = [T, T, T, T, ...T[]];\nexport type Array5<T> = [T, T, T, T, T, ...T[]];\nexport type Array6<T> = [T, T, T, T, T, T, ...T[]];\nexport type Array7<T> = [T, T, T, T, T, T, T, ...T[]];\n\nexport function map<T, U>(\n  arr: Array1<T>,\n  callbackfn: (value: T, index: number) => U\n): Array1<U>;\nexport function map<T, U>(\n  arr: Array2<T>,\n  callbackfn: (value: T, index: number) => U\n): Array2<U>;\nexport function map<T, U>(\n  arr: T[],\n  callbackfn: (value: T, index: number) => U\n): U[];\nexport function map<T, U>(\n  arr: T[],\n  callbackfn: (value: T, index: number) => U\n): U[] {\n  return arr.map(callbackfn);\n}\n\nexport function atLeast<T>(n: 1, arr: T[]): arr is Array1<T>;\nexport function atLeast<T>(n: 2, arr: T[]): arr is Array2<T>;\nexport function atLeast<T>(n: 3, arr: T[]): arr is Array3<T>;\nexport function atLeast<T>(n: number, arr: T[]): arr is T[] {\n  return arr.length >= n;\n}\n\n/**\n * Wrapper around the `in` operator.\n * By default the `in` operator narrows the object (this is useful if the object\n * is a union type). We want to do the reverse, that is narrow down the key.\n * https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing\n *\n * @param obj The object the keys of which we want to narrow to\n * @param key The key we want to check if is in the object\n */\nexport function isKeyOf<T extends object>(\n  obj: T,\n  key: string | number | symbol\n): key is keyof T {\n  return key in obj;\n}\n\n/**\n * Type guard that returns true if the passed array has the exact length as specified\n *\n * @param length The expected length of the array\n * @param arr The array the length of which we test\n */\nexport function excactly<T>(length: 1, arr: T[]): arr is [T];\nexport function excactly<T>(length: 2, arr: T[]): arr is [T, T];\nexport function excactly<T>(length: 3, arr: T[]): arr is [T, T, T];\nexport function excactly<T>(length: number, arr: T[]): arr is T[] {\n  return arr.length === length;\n}\n\n/**\n * Type guard that returns true if the value is not null or undefined\n *\n * The main usage is the filter function: `something.filter(notEmpty)`\n *\n * @param value A value that may or may not be null/undefined\n */\nexport function notEmpty<TValue>(\n  value: TValue | null | undefined\n): value is TValue {\n  return value !== null && value !== undefined;\n}\n\nexport function atMod<T>(arr: Array1<T>, indexMod: number): T {\n  const len = arr.length;\n  const elem = arr[(indexMod + len) % len];\n\n  return elem ?? arr[0];\n}\n\n// TODO: Write this better\n// export function groupBy<T extends {}, K extends string>(\n//   arr: (T & { [k in K]?: string })[],\n//   key: K\n// ): { [k: string]: Array1<T> } {\n//   const retObj: { [k: string]: Array1<T> } = {};\n//\n//   arr.forEach((elem) => {\n//     if (!(key in elem)) return;\n//\n//     const elemVal: string | undefined = elem[key];\n//\n//     if (!elemVal) return;\n//\n//     if (isKeyOf(retObj, elemVal)) {\n//       retObj[elemVal].push(elem);\n//     } else {\n//       retObj[elemVal] = [elem];\n//     }\n//   });\n//\n//   return retObj;\n// }\n\n// Maybe rewrite this more beautifully\nexport function zip<T, B>(arrT: Array1<T>, arrB: Array1<B>): Array1<[T, B]> {\n  const first: [T, B] = [arrT[0], arrB[0]];\n\n  const rest = map(arrT, (tVal, index) => {\n    // First element was already extracted\n    if (index === 0) return null;\n\n    const bVal = arrB[index];\n\n    if (!bVal) return null;\n\n    const tup: [T, B] = [tVal, bVal];\n\n    return tup;\n  }).filter(notEmpty);\n\n  return [first, ...rest];\n}\n\n/**\n * Returns the last element of the array\n * If the array is Array1, it will return `T`\n * otherwise it will return `T | undefined`\n *\n * @param arr An array of elements\n */\nexport function last<T>(arr: Array1<T>): T;\nexport function last<T>(arr: T[]): T | undefined;\nexport function last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\n/**\n * Filter the values of an array in 2 groups based on the predicate\n *\n * @param arr Array with some values\n * @param pred The predicate\n */\nexport function split<T>(\n  arr: T[],\n  pred: (elem: T, index: number) => boolean\n): { good: T[]; bad: T[] } {\n  const good = arr.filter((elem, index) => pred(elem, index));\n  const bad = arr.filter((elem, index) => !pred(elem, index));\n\n  return { good, bad };\n}\n\n/**\n * Wrapper over `Promise.all()` that maintains the guarantees of the passed array\n *\n * @param promises A list of promises\n */\nexport function promiseAll<T>(promises: Array3<Promise<T>>): Promise<Array3<T>>;\nexport function promiseAll<T>(promises: Array2<Promise<T>>): Promise<Array2<T>>;\nexport function promiseAll<T>(promises: Array1<Promise<T>>): Promise<Array1<T>>;\nexport function promiseAll<T>(promises: Promise<T>[]): Promise<T[]>;\nexport function promiseAll<T>(promises: Promise<T>[]): Promise<T[]> {\n  return Promise.all(promises);\n}\n\n/**\n * Wrapper over `Promise.all(array.map(callback))` that maintains the guarantees of the array\n */\nexport function mapAll<T, B>(\n  arr: Array3<T>,\n  callback: (value: T, index: number) => Promise<B>\n): Promise<Array3<B>>;\nexport function mapAll<T, B>(\n  arr: Array2<T>,\n  callback: (value: T, index: number) => Promise<B>\n): Promise<Array2<B>>;\nexport function mapAll<T, B>(\n  arr: Array1<T>,\n  callback: (value: T, index: number) => Promise<B>\n): Promise<Array1<B>>;\nexport function mapAll<T, B>(\n  arr: T[],\n  callback: (value: T, index: number) => Promise<B>\n): Promise<B[]>;\nexport function mapAll<T, B>(\n  arr: T[],\n  callback: (value: T, index: number) => Promise<B>\n): Promise<B[]> {\n  return Promise.all(arr.map(callback));\n}\n\n/**\n * Reverses an array (creates a new array) maintaining its guarantees\n *\n * @param arr The array to reverse\n */\nexport function reverse<T>(arr: Array3<T>): Array3<T>;\nexport function reverse<T>(arr: Array2<T>): Array2<T>;\nexport function reverse<T>(arr: Array1<T>): Array1<T>;\nexport function reverse<T>(arr: Array1<T>): Array1<T>;\nexport function reverse<T>(arr: T[]): T[] {\n  const tempArr = [...arr];\n\n  tempArr.reverse();\n\n  return tempArr;\n}\n\n/**\n * Wrapper around `splice` that doesn't modify the initial array\n *\n * @param array\n * @param start\n * @param count\n * @param values\n */\nexport function immutableSplice<T>(\n  array: T[],\n  start: number,\n  count: number,\n  ...values: T[]\n): T[] {\n  const newArr = [...array];\n  newArr.splice(start, count, ...values);\n  return newArr;\n}\n\n/**\n * Wrapper around `Object.keys` that returns a typed array instead of `string[]`\n *\n * @param value\n */\nexport function objKeys<T>(value: T): (keyof T)[] {\n  // @ts-expect-error This is expected\n  return Object.keys(value);\n}\n\n/**\n * This function can be added in the default case of a switch statement\n * so that the switch is exhaustive (https://stackoverflow.com/a/39419171)\n * When this is added typescript will show an error if one of the possibilities\n * of an enum was not taken into account. See Compose.js setContent() for example\n */\nexport function unreachable(v: never): never {\n  return v;\n}\n\nexport function promiseTimeout(millis: number) {\n  return new Promise<undefined>((resolve, reject) => {\n    try {\n      setTimeout(resolve, millis);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n/**\n * Wrapper around `Array.includes()` that is also a type guard and doesn't err if the value\n * is not guaranteed to be in the given array\n *\n * @param arr\n * @param value\n */\nexport function includes<T>(arr: T[], value: unknown): value is T {\n  // @ts-ignore\n  return arr.includes(value);\n}\n"],"names":["map","arr","callbackfn","notEmpty","value","n","length","indexMod","len","elem","array","start","count","newArr","values","splice","includes","obj","key","callback","Promise","all","Object","keys","promises","millis","resolve","reject","setTimeout","error","tempArr","reverse","pred","good","filter","index","bad","v","arrT","arrB","first","rest","tVal","bVal"],"mappings":"sBAwFgBA,EACdC,EACAC,GAEA,OAAOD,EAAID,IAAIE,YA8CDC,EACdC,GAEA,OAAOA,MAAAA,kFA3CkBC,EAAWJ,GACpC,OAAOA,EAAIK,QAAUD,0BA6CEJ,EAAgBM,GACvC,IAAMC,EAAMP,EAAIK,OACVG,EAAOR,GAAKM,EAAWC,GAAOA,GAEpC,aAAOC,EAAAA,EAAQR,EAAI,8BArBOK,EAAgBL,GAC1C,OAAOA,EAAIK,SAAWA,oCAiKtBI,EACAC,EACAC,GAG0B,IAA1B,IAAMC,YAAaH,sBAFhBI,mCAAAA,oBAIH,OADAD,EAAOE,aAAPF,GAAcF,EAAOC,UAAUE,IACxBD,6BAwCmBZ,EAAUG,GAEpC,OAAOH,EAAIe,SAASZ,6BAlOpBa,EACAC,GAEA,OAAOA,KAAOD,yBAyFQhB,GACtB,OAAOA,EAAIA,EAAIK,OAAS,0CAoDxBL,EACAkB,GAEA,OAAOC,QAAQC,IAAIpB,EAAID,IAAImB,iDA4CFf,GAEzB,OAAOkB,OAAOC,KAAKnB,gCAzESoB,GAC5B,OAAOJ,QAAQC,IAAIG,oCAqFUC,GAC7B,OAAO,IAAIL,SAAmB,SAACM,EAASC,GACtC,IACEC,WAAWF,EAASD,GACpB,MAAOI,GACPF,EAAOE,iCApDc5B,GACzB,IAAM6B,YAAc7B,GAIpB,OAFA6B,EAAQC,UAEDD,0BA9DP7B,EACA+B,GAKA,MAAO,CAAEC,KAHIhC,EAAIiC,QAAO,SAACzB,EAAM0B,GAAK,OAAKH,EAAKvB,EAAM0B,MAGrCC,IAFHnC,EAAIiC,QAAO,SAACzB,EAAM0B,GAAK,OAAMH,EAAKvB,EAAM0B,qCAgG1BE,GAC1B,OAAOA,wBA5IiBC,EAAiBC,GACzC,IAAMC,EAAgB,CAACF,EAAK,GAAIC,EAAK,IAE/BE,EAAOzC,EAAIsC,GAAM,SAACI,EAAMP,GAE5B,GAAc,IAAVA,EAAa,OAAO,KAExB,IAAMQ,EAAOJ,EAAKJ,GAElB,OAAKQ,EAEe,CAACD,EAAMC,GAFT,QAKjBT,OAAO/B,GAEV,OAAQqC,UAAUC"}