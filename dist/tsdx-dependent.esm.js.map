{"version":3,"file":"tsdx-dependent.esm.js","sources":["../src/object.ts","../src/index.ts"],"sourcesContent":["/**\n * Wrapper around `Object.keys` that returns a typed array instead of `string[]`\n *\n * @param value\n */\nexport function objKeys<T extends object>(value: T): (keyof T)[] {\n  return Object.keys(value) as (keyof T)[];\n}\n\nexport function objEntries<T extends object>(\n  value: T\n): [keyof T, T[keyof T]][] {\n  return Object.entries(value) as [keyof T, T[keyof T]][];\n}\n","export * from './object';\n\n// https://stackoverflow.com/a/50375286/2659549\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never;\n\nexport type UnpackPromise<T> = T extends Promise<infer U> ? U : T;\n\n/**\n * Use this instead of {}. It seems that {} causes problems especially when used in generics.\n */\nexport type EmptyObject = Record<string, unknown>;\n\nexport type Arguments<T extends (...args: unknown[]) => unknown> = T extends (\n  ...args: infer R\n) => unknown\n  ? R\n  : never;\nexport type FirstArgument<T extends (arg: any, ...args: any[]) => any> =\n  T extends (val: infer R, ...args: any[]) => any ? R : never;\nexport type SecondArgument<\n  T extends (first: any, second: any, ...args: any[]) => any\n> = T extends (first: any, second: infer R, ...args: any[]) => any ? R : never;\n\n/**\n * Given a function of type `(v: A) => Ap | (v: B) => Bp`\n * transform it's type into `(v: A | B) => Ap | Bp`\n */\nexport type UnionFuncFix<F extends (arg: any) => any> = (\n  value: FirstArgument<F>\n) => ReturnType<F>;\n\n// https://www.roryba.in/programming/2019/10/12/flattening-typescript-union-types.html\n// Flattens two union types into a single type with optional values\n// i.e. FlattenUnion<{ a: number, c: number } | { b: string, c: number }> = { a?: number, b?: string, c: number }\nexport type FlattenUnion<T> = {\n  [K in keyof UnionToIntersection<T>]: K extends keyof T\n    ? T[K] extends unknown[]\n      ? T[K] // eslint-disable-next-line @typescript-eslint/ban-types\n      : T[K] extends object\n      ? FlattenUnion<T[K]>\n      : T[K]\n    : UnionToIntersection<T>[K] | undefined;\n};\n\n/**\n * Different implementation of Array1/Array2/...\n *\n * Not sure if it provides any advantages\n */\nexport type ArrayN<N extends number, T> = N extends 1\n  ? [T, ...T[]]\n  : N extends 2\n  ? [T, T, ...T[]]\n  : N extends 3\n  ? [T, T, T, ...T[]]\n  : N extends 4\n  ? [T, T, T, T, ...T[]]\n  : N extends 5\n  ? [T, T, T, T, T, ...T[]]\n  : N extends 6\n  ? [T, T, T, T, T, T, ...T[]]\n  : N extends 7\n  ? [T, T, T, T, T, T, T, ...T[]]\n  : T[];\n\nexport type Array1<T> = [T, ...T[]];\nexport type Array2<T> = [T, T, ...T[]];\nexport type Array3<T> = [T, T, T, ...T[]];\nexport type Array4<T> = [T, T, T, T, ...T[]];\nexport type Array5<T> = [T, T, T, T, T, ...T[]];\nexport type Array6<T> = [T, T, T, T, T, T, ...T[]];\nexport type Array7<T> = [T, T, T, T, T, T, T, ...T[]];\n\nexport function map<T, U>(\n  arr: Array1<T>,\n  callbackfn: (value: T, index: number) => U\n): Array1<U>;\nexport function map<T, U>(\n  arr: Array2<T>,\n  callbackfn: (value: T, index: number) => U\n): Array2<U>;\nexport function map<T, U>(\n  arr: T[],\n  callbackfn: (value: T, index: number) => U\n): U[];\nexport function map<T, U>(\n  arr: T[],\n  callbackfn: (value: T, index: number) => U\n): U[] {\n  return arr.map(callbackfn);\n}\n\nexport function atLeast<T>(n: 1, arr: T[]): arr is Array1<T>;\nexport function atLeast<T>(n: 2, arr: T[]): arr is Array2<T>;\nexport function atLeast<T>(n: 3, arr: T[]): arr is Array3<T>;\nexport function atLeast<T>(n: number, arr: T[]): arr is T[] {\n  return arr.length >= n;\n}\n\n/**\n * Wrapper around the `in` operator.\n * By default the `in` operator narrows the object (this is useful if the object\n * is a union type). We want to do the reverse, that is narrow down the key.\n * https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing\n *\n * @param obj The object the keys of which we want to narrow to\n * @param key The key we want to check if is in the object\n */\nexport function isKeyOf<T extends object>(\n  obj: T,\n  key: string | number | symbol\n): key is keyof T {\n  return key in obj;\n}\n\n/**\n * Type guard that returns true if the passed array has the exact length as specified\n *\n * @param length The expected length of the array\n * @param arr The array the length of which we test\n */\nexport function excactly<T>(length: 1, arr: T[]): arr is [T];\nexport function excactly<T>(length: 2, arr: T[]): arr is [T, T];\nexport function excactly<T>(length: 3, arr: T[]): arr is [T, T, T];\nexport function excactly<T>(length: number, arr: T[]): arr is T[] {\n  return arr.length === length;\n}\n\n/**\n * Type guard that returns true if the value is not null or undefined\n *\n * The main usage is the filter function: `something.filter(notEmpty)`\n *\n * @param value A value that may or may not be null/undefined\n */\nexport function notEmpty<TValue>(\n  value: TValue | null | undefined\n): value is TValue {\n  return value !== null && value !== undefined;\n}\n\nexport function atMod<T>(arr: Array1<T>, indexMod: number): T {\n  const len = arr.length;\n  const elem = arr[(indexMod + len) % len];\n\n  return elem ?? arr[0];\n}\n\n// TODO: Write this better\n// export function groupBy<T extends {}, K extends string>(\n//   arr: (T & { [k in K]?: string })[],\n//   key: K\n// ): { [k: string]: Array1<T> } {\n//   const retObj: { [k: string]: Array1<T> } = {};\n//\n//   arr.forEach((elem) => {\n//     if (!(key in elem)) return;\n//\n//     const elemVal: string | undefined = elem[key];\n//\n//     if (!elemVal) return;\n//\n//     if (isKeyOf(retObj, elemVal)) {\n//       retObj[elemVal].push(elem);\n//     } else {\n//       retObj[elemVal] = [elem];\n//     }\n//   });\n//\n//   return retObj;\n// }\n\n// Maybe rewrite this more beautifully\nexport function zip<T, B>(arrT: Array1<T>, arrB: Array1<B>): Array1<[T, B]> {\n  const first: [T, B] = [arrT[0], arrB[0]];\n\n  const rest = map(arrT, (tVal, index) => {\n    // First element was already extracted\n    if (index === 0) return null;\n\n    const bVal = arrB[index];\n\n    if (!bVal) return null;\n\n    const tup: [T, B] = [tVal, bVal];\n\n    return tup;\n  }).filter(notEmpty);\n\n  return [first, ...rest];\n}\n\n/**\n * Returns the last element of the array\n * If the array is Array1, it will return `T`\n * otherwise it will return `T | undefined`\n *\n * @param arr An array of elements\n */\nexport function last<T>(arr: Array1<T>): T;\nexport function last<T>(arr: T[]): T | undefined;\nexport function last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\n/**\n * Filter the values of an array in 2 groups based on the predicate\n *\n * @param arr Array with some values\n * @param pred The predicate\n */\nexport function split<T>(\n  arr: T[],\n  pred: (elem: T, index: number) => boolean\n): { good: T[]; bad: T[] } {\n  const good = arr.filter((elem, index) => pred(elem, index));\n  const bad = arr.filter((elem, index) => !pred(elem, index));\n\n  return { good, bad };\n}\n\n/**\n * Wrapper over `Promise.all()` that maintains the guarantees of the passed array\n *\n * @param promises A list of promises\n */\nexport function promiseAll<T>(promises: Array3<Promise<T>>): Promise<Array3<T>>;\nexport function promiseAll<T>(promises: Array2<Promise<T>>): Promise<Array2<T>>;\nexport function promiseAll<T>(promises: Array1<Promise<T>>): Promise<Array1<T>>;\nexport function promiseAll<T>(promises: Promise<T>[]): Promise<T[]>;\nexport function promiseAll<T>(promises: Promise<T>[]): Promise<T[]> {\n  return Promise.all(promises);\n}\n\n/**\n * Wrapper over `Promise.all(array.map(callback))` that maintains the guarantees of the array\n */\nexport function mapAll<T, B>(\n  arr: Array3<T>,\n  callback: (value: T, index: number) => Promise<B>\n): Promise<Array3<B>>;\nexport function mapAll<T, B>(\n  arr: Array2<T>,\n  callback: (value: T, index: number) => Promise<B>\n): Promise<Array2<B>>;\nexport function mapAll<T, B>(\n  arr: Array1<T>,\n  callback: (value: T, index: number) => Promise<B>\n): Promise<Array1<B>>;\nexport function mapAll<T, B>(\n  arr: T[],\n  callback: (value: T, index: number) => Promise<B>\n): Promise<B[]>;\nexport function mapAll<T, B>(\n  arr: T[],\n  callback: (value: T, index: number) => Promise<B>\n): Promise<B[]> {\n  return Promise.all(arr.map(callback));\n}\n\n/**\n * Reverses an array (creates a new array) maintaining its guarantees\n *\n * @param arr The array to reverse\n */\nexport function reverse<T>(arr: Array3<T>): Array3<T>;\nexport function reverse<T>(arr: Array2<T>): Array2<T>;\nexport function reverse<T>(arr: Array1<T>): Array1<T>;\nexport function reverse<T>(arr: Array1<T>): Array1<T>;\nexport function reverse<T>(arr: T[]): T[] {\n  const tempArr = [...arr];\n\n  tempArr.reverse();\n\n  return tempArr;\n}\n\n/**\n * Wrapper around `splice` that doesn't modify the initial array\n *\n * @param array\n * @param start\n * @param count\n * @param values\n */\nexport function immutableSplice<T>(\n  array: T[],\n  start: number,\n  count: number,\n  ...values: T[]\n): T[] {\n  const newArr = [...array];\n  newArr.splice(start, count, ...values);\n  return newArr;\n}\n\n/**\n * This function can be added in the default case of a switch statement\n * so that the switch is exhaustive (https://stackoverflow.com/a/39419171)\n * When this is added typescript will show an error if one of the possibilities\n * of an enum was not taken into account. See Compose.js setContent() for example\n */\nexport function unreachable(v: never): never {\n  return v;\n}\n\nexport function promiseTimeout(millis: number) {\n  return new Promise<undefined>((resolve, reject) => {\n    try {\n      setTimeout(resolve, millis);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n/**\n * Wrapper around `Array.includes()` that is also a type guard and doesn't err if the value\n * is not guaranteed to be in the given array\n *\n * @param arr\n * @param value\n */\nexport function includes<T>(arr: T[], value: unknown): value is T {\n  // @ts-ignore\n  return arr.includes(value);\n}\n"],"names":["objKeys","value","Object","keys","objEntries","entries","map","arr","callbackfn","atLeast","n","length","isKeyOf","obj","key","excactly","notEmpty","undefined","atMod","indexMod","len","elem","zip","arrT","arrB","first","rest","tVal","index","bVal","tup","filter","last","split","pred","good","bad","promiseAll","promises","Promise","all","mapAll","callback","reverse","tempArr","immutableSplice","array","start","count","newArr","values","splice","unreachable","v","promiseTimeout","millis","resolve","reject","setTimeout","error","includes"],"mappings":"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"}